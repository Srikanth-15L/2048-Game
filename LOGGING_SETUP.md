# Logging Middleware Setup

This project implements a comprehensive logging middleware system that sends structured logs to a Test Server API as required by the evaluation criteria.

## Architecture

The logging system consists of:

1. **Reusable Log Function** (`src/loggingMiddleware.js`) - Makes API calls to Test Server
2. **Express Middleware** - Automatically logs HTTP requests/responses
3. **Test Server** (`test-server.js`) - Receives and stores log entries
4. **Structured Logging** - Follows `Log(stack, level, package, message)` format

## Log Function Structure

```javascript
Log(stack, level, package, message)
```

- **stack**: Current execution context/stack trace
- **level**: Log level (info, warn, error, debug)
- **package**: Package/module name where the log originated
- **message**: Descriptive message about what's happening

## Quick Start

### 1. Install Dependencies

```bash
npm install
```

### 2. Start Both Servers

```bash
# Development mode with auto-restart
npm run dev:all

# Production mode
npm run start:all
```

This starts:
- **Main Application**: `http://localhost:3001`
- **Test Server**: `http://localhost:3002`

### 3. Test the Logging

```bash
# Create a short URL to trigger logs
curl -X POST http://localhost:3001/shorturls \
  -H "Content-Type: application/json" \
  -d '{"url": "https://example.com"}'

# View logs on Test Server
curl http://localhost:3002/api/logs
```

## Usage Examples

### Basic Logging

```javascript
const { Log, Logger } = require('./src/loggingMiddleware');

// Direct Log function usage
Log('user-authentication', 'info', 'auth', 'User login attempt');
Log('database-connection', 'error', 'db', 'Connection failed');

// Using utility functions
Logger.info('user-registration', 'auth', 'New user registered');
Logger.error('payment-processing', 'payment', 'Credit card declined');
```

### Context-Rich Logging Examples

```javascript
// Backend validation error
Log("backend", "error", "handler", "received string, expected bool");

// Database layer error
Log("backend", "fatal", "db", "Critical database connection failure.");

// URL creation success
Log('POST /shorturls success', 'info', 'url-creation', `Short URL created: abc123 -> https://example.com`);

// Analytics request
Log('GET /analytics', 'info', 'analytics', 'Statistics retrieved for shortcode abc123: 42 total clicks');
```

## Test Server API

### Endpoints

- `POST /api/logs` - Receive log entries
- `GET /api/logs` - Retrieve stored logs (with filtering)
- `GET /api/stats` - View logging statistics
- `DELETE /api/logs` - Clear all logs (testing)
- `GET /health` - Health check

### Query Parameters for GET /api/logs

- `level` - Filter by log level (info, warn, error, debug)
- `package` - Filter by package name
- `limit` - Number of logs to return (default: 100)

Example: `GET /api/logs?level=error&package=auth&limit=10`

## Configuration

### Environment Variables

```bash
# Main application port
PORT=3001

# Test server configuration
TEST_SERVER_PORT=3002
TEST_SERVER_URL=http://localhost:3002
```

### Fallback Behavior

If the Test Server is unavailable:
- Logs are printed to console as fallback
- Application continues to function normally
- No data loss occurs

## Integration Points

The logging middleware is integrated at these key points:

1. **HTTP Middleware** - All incoming requests and responses
2. **URL Creation** - Short URL generation and validation
3. **URL Redirection** - Access attempts and redirects
4. **Analytics** - Statistics requests and data retrieval
5. **Error Handling** - All application errors and 404s
6. **Server Lifecycle** - Startup and shutdown events

## Development

### Running Individual Servers

```bash
# Main application only
npm start

# Test server only
npm run test-server

# Development with auto-restart
npm run dev
```

### Monitoring Logs

```bash
# View all logs
curl http://localhost:3002/api/logs

# View only errors
curl "http://localhost:3002/api/logs?level=error"

# View analytics package logs
curl "http://localhost:3002/api/logs?package=analytics"

# View statistics
curl http://localhost:3002/api/stats
```

## Log Examples from Application

Here are examples of logs generated by different application scenarios:

### Successful URL Creation
```json
{
  "stack": "POST /shorturls success",
  "level": "info",
  "package": "url-creation",
  "message": "Short URL created successfully: abc123 -> https://example.com"
}
```

### URL Access
```json
{
  "stack": "GET /shorturls/:shortcode success",
  "level": "info",
  "package": "url-redirect",
  "message": "Redirecting abc123 to original URL: https://example.com"
}
```

### Validation Error
```json
{
  "stack": "POST /shorturls validation",
  "level": "error",
  "package": "validation",
  "message": "Validation failed: url is required"
}
```

### Analytics Request
```json
{
  "stack": "GET /shorturls/:shortcode/stats success",
  "level": "info",
  "package": "analytics",
  "message": "Statistics retrieved for abc123: 5 total clicks"
}
```

## Troubleshooting

### Test Server Connection Issues

If logs aren't appearing in the Test Server:

1. Check if Test Server is running: `curl http://localhost:3002/health`
2. Verify TEST_SERVER_URL environment variable
3. Check console for fallback logs
4. Ensure both servers are running on different ports

### Missing Logs

If expected logs aren't appearing:

1. Verify the Log function is being called with all 4 parameters
2. Check the Test Server logs for any error messages
3. Use the fallback console logs for debugging

## Performance Considerations

- Log calls are asynchronous and non-blocking
- 5-second timeout on Test Server requests
- Automatic fallback to console logging
- Minimal impact on application performance

## Security Notes

- Logs may contain sensitive information (URLs, IPs)
- Test Server stores logs in memory (not persistent)
- Consider log rotation and retention policies for production
- Validate and sanitize log content in production environments